# MeDF ユースケースと仕様拡張

## Step 3｜署名を「思想に反しない形」で入れる

### 結論

**署名は 信頼を付与しない。**
**署名は 「誰が固定したか」を示すだけ。**

### 署名の位置づけ

| 要素 | 役割 |
|------|------|
| `doc_hash` | 状態の固定 |
| `signature` | 固定者の表明 |
| `public_key` | 検証素材（主張ではない） |

👉 **署名＝信用ではない**

### オフライン成立の最小構成

```json
{
  "signature": {
    "algorithm": "ed25519",
    "value": "base64...",
    "signer": "example:author",
    "public_key": "base64...",
    "signed_at": "2026-02-05T12:00:00Z"
  }
}
```

### 署名の原則

- **失効確認しない** - 鍵の失効状態は追跡しない
- **権威検証しない** - CAや信頼済みサードパーティは不使用
- **ただ一致を見るだけ** - 署名が公開鍵で検証できればOK

### 思想との整合性

これは「正しさを証明しない」「存在を記録する」という思想と完全一致します。

- 署名 = 「この人物が、この時点に、この内容に署名した」という事実の記録
- 内容の真偽や、署名者の権威とは無関係
- 「誰が言ったか」の証明であって、「何が正しいか」の証明ではない

---

## Step 4｜論文ユースケース（強い）

### 既存の論文が抱える問題

1. **arXiv / journal / PDF が別物**
   - プレプリントと査読付き版が別のURLとして存在
   - どちらが「公式」か不明確

2. **改訂履歴が読者に伝わらない**
   - v1, v2, v3 と番号が付いているが、何が変わったか不明
   - 引用元がどの版を参照しているか不明

3. **引用が「版」を指していない**
   - 「Smith (2020)」では、どの版か不明
   - 結論が改訂で変わっている可能性がある

### MEDFでどう変わるか

**論文 = blocks**

```json
{
  "blocks": [
    {
      "id": "abstract",
      "block_hash": "sha256:...",
      "content": "..."
    },
    {
      "id": "methodology",
      "block_hash": "sha256:...",
      "content": "..."
    },
    {
      "id": "results",
      "block_hash": "sha256:...",
      "content": "..."
    },
    {
      "id": "discussion",
      "block_hash": "sha256:...",
      "content": "..."
    }
  ]
}
```

### 各ブロックに block_hash

- セクション単位でハッシュを付与
- 特定の主張（methodology, resultsなど）を個別に参照可能
- ブロックが更新されると、block_hashが変化

### 引用がこうなる

```
MEDF: paper-2026-xyz@v3#methodology
```

👉 **「この論文」ではなく「この版の、この主張」を指せる**

### 既存制度との共存

**重要ポイント**:

- ✅ 雑誌は不要にならない
- ✅ 査読も否定しない
- ✅ 状態固定層を追加するだけ

既存制度と衝突しません。MeDFは「状態の記録」に集中し、評価・判定は既存システムに委ねます。

---

## Step 5｜偽アカウント問題への適用整理

### 問題の本質

SNSの偽アカウント問題は、
**本人確認ではなく
発言の同一性が保証されないこと。**

### MEDFができること

- ✅ 「この文章は、過去にこの鍵で固定された」
- ✅ 「この文章は、過去の文章と同一鍵で署名されている」

❌ 「この人が言ったか」は別問題

👉 **なりすましを防ぐのではない**
👉 **「同一人物の継続性」を検証可能にする**

### 実運用イメージ

1. **本人が声明文を MEDF 化**
   - 公式声明をMeDFとして保存
   - ed25519で署名

2. **SNSプロフィールに medf_id を貼る**
   - `MEDF: @username@2026-02-05T12:00:00Z`
   - 公開鍵も併記

3. **後続声明が同一鍵か検証可能**
   - 過去の声明と同じ公開鍵で署名されているか確認
   - 鍵の連続性を検証

### メリット

- ✅ 中央認証なし
- ✅ ブロックチェーン不要
- ✅ 本人確認情報（パスポート等）不要
- ✅ 鍵の連続性で「同一人物の継続性」を証明可能

### 限界

- ❌ 本人確認（KYC）は別問題
- ❌ 鍵の盗難に対処は別途必要
- ❌ 「初めての本人確認」は解決しない

### 思想との整合性

これは「信頼を強制しない」「評価から切り離した記録」という思想と一致します。

- MeDFは「この鍵で署名された」という事実を記録
- 「この鍵の持ち主が本人か」は利用者の判断
- 鍵の継続性が「同一人物の根拠」になる

---

## 仕様統合

### 署名フィールド（v0.2拡張）

```json
{
  "medf_version": "0.2",
  "signature": {
    "algorithm": "ed25519",
    "value": "base64...",
    "signer": "did:example:123",
    "public_key": "base64...",
    "signed_at": "2026-02-05T12:00:00Z"
  }
}
```

### ブロック構造（論文拡張）

```json
{
  "medf_version": "0.2",
  "document_type": "academic_paper",
  "blocks": [
    {
      "id": "abstract",
      "block_hash": "sha256:...",
      "content": "...",
      "role": "abstract"
    }
  ],
  "citations": [
    {
      "medf_id": "paper-2026-xyz@v3#methodology",
      "context": "Our methodology builds on..."
    }
  ]
}
```

### 引用形式

```
MEDF: paper-2026-xyz@v3#methodology
```

- `paper-2026-xyz` - 論文ID
- `@v3` - バージョン
- `#methodology` - ブロックID

---

## まとめ

### 署名（Step 3）

- 信頼を付与しない
- 「誰が固定したか」を示すだけ
- オフラインで成立する

### 論文（Step 4）

- blocks構造でセクション分割
- 引用は「版」と「ブロック」を指定
- 既存制度と共存

### 偽アカウント（Step 5）

- 「発言の同一性」を保証
- 鍵の継続性で「同一人物」を証明
- 中央認証不要

すべて「信頼を強制しない」「評価から切り離した記録」という思想と完全一致します。
